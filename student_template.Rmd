---
title: "Housing data analysis - Women Who Code workshop"
author: "Yournamehere"
date: "13/03/2018"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
load.libraries <- c('tidyverse', 'forcats', 'corrplot', 'caret', 'Metrics', 'randomForest', 'xgboost', 'glmnet', 'car')
# note car only for Darya to use the demo dataset
install.lib <- load.libraries[!load.libraries %in% installed.packages()]
for(libs in install.lib) install.packages(libs, dependences = TRUE)
sapply(load.libraries, library, character = TRUE)
knitr::opts_chunk$set(echo = TRUE)
```

Load the data in from csv. 

```{r ReadData}
trainH <- read.csv("train.csv")
testH <- read.csv("test.csv")
```

What features are there in the data? What are the dimensions of the data? What are the column headers? Use the summary() and str() functions to explore...



```{r WhatFeat}

```

# What does the distribution of sale price look like?

Is the sale price (the variable we're interested in prediting) normally distributed? Find its mean, standard deviation, and plot a histogram of the distribution using ggplot2.


```{r PlotSalehistogram}

```

Plot a quantile-quantile plot (QQ plot) to "assess" normality. This plot compared the data we have (Sample Quantiles) with a theoretical sample coming from a normal distribution.  Each point (x, y) corresponds to one of the quantiles of the second distribution (x-coordinate, theoretical) plotted against the same quantile of the first distribution (y-coordinate, our data). Thus the line is a parametric curve with the parameter which is the number of the interval for the quantile.

```{r QQPlot}

```

A standard way of transforming the data to be better approximated by a normal distribution is by using the log-transform? 

Carry out this transformation and use a histogram and QQ plot to see whether it works...


```{r LogTransform}

```



# Missing data
What happens if we only use complete data? How much data is missing?

```{r whatsmissing}

```

We need to combine the datasets for imputation, so that we don't have NAs in the test data as well!

```{r combineAlldata}

```


How do we impute the missing data?


```{r ExploreUsingTable}

```

Read the metadata file and see that many of the NAs should be recoded as None since these features are lacking in the house. 


```{r missingBasedOnDescription}

```

For the GarageYrBlt set to zero. 


```{r missingSetToZero}

```

Lot frontage - set as median for the neighborhood.

```{r LotFrontageMedian}
# as a hint - use group_by() and mutate()
# will also need ifelse() function
```


# Now split data again
Split back into training (trainHC) and test (testHC) sets (because kaggle training set had prices, test didn't).

```{r split}
# no comment
```



# Basic exploratory data analysis of training data

How does the sale price depend on living  area: X1stFlrSF, X2ndFlrSF, TotalBsmtSF? Create a variable TotalSqFt which is a combination of these 3. Does it better predict the house price?

```{r SalePriceExplore}

```

Identify and remove outliers with a high total square foot, but low price

```{r RemoveOut}

```



Does having more bedrooms increase sale price?

```{r Bedroom}

```


Visualise both number of bedrooms (as a factor) and TotalSqFt as a scatterplot to see if a trend is visible. 


```{r CombineAreaAndSqFt}


```

Are newer or more recently renovated properties more expensive? Investigate this generally and then specifically for 2 - 4 bedroom properties.

```{r YrBltRemodelled}

```


Lets convert kitchen quality to numeric (we'll see why we need this later):

From the metadata we know it can be:

- Ex	Excellent
- Gd	Good
- TA	Typical/Average
- Fa	Fair
- Po	Poor

Recode this to numeric values using mutate() and recode(). 

```{r ConvertToNumeric}

```

Convert Bldgtype to numeric

```{r BldgTypeNeighborhood}

```


What variables are correlated with each other and with price? Plot a correlation plot using corrplot() for all numeric variables and those that show the top correlation with LogSalePrice.

```{r Corrplot}

```

Use the createDataPartition() function to separate the training data into a training and testing subset. Allocate 50% of the data to each class. Run set.seed(12) before this.

```{r MakeTestTrain}
set.seed(12)
```

Fit a linear model considering the "top 10"" correlated (top 9, ignore LogSalePrice for obvious reasons).

```{r lm}

```

Use predict() to predict house prices using our top10 model on the "test" portion of the training dataset. Use rmse to assess the root mean square error (our metric of accuracy). 


```{r HowdWeGo}

```

Use randomForest to train a random forest model on all of the variables. Use predict and rmse to make the prediction and assess the accuracy respectively. Was a linear (on 9 features) or random forest model more accurate?

```{r RandomForest}
# randFor <- randomForest(LogSalePrice ~ ., data=trainHCtrain)
# # Predict using the test set
# prediction_rf <- predict(randFor, trainHCtest)
# trainHCtest$randFor <- prediction_rf
# # rmse?
# rmse(trainHCtest$LogSalePrice, trainHCtest$randFor)
```

Use xgboost to predict house prices from numeric features of training dataset. 

Use xgb.plot.importance() to assess which variables are most important for predicting house prices. 

```{r NumericOnlyXGboost}
# trainHCtrainNum <- as(as.matrix(trainHCtrain[ , sapply(trainHCtrain, is.numeric)]), "sparseMatrix")
# trainHCtestNum <-  as(as.matrix(trainHCtest[ , sapply(trainHCtest, is.numeric)]), "sparseMatrix")
# 
# trainD <- xgb.DMatrix(data = trainHCtrainNum, label = trainHCtrainNum[,"LogSalePrice"])
# 
# #Cross validate the model
# cv.sparse <- xgb.cv(data = trainD,
#                     nrounds = 600,
#                     min_child_weight = 0,
#                     max_depth = 10,
#                     eta = 0.02,
#                     subsample = .7,
#                     colsample_bytree = .7,
#                     booster = "gbtree",
#                     eval_metric = "rmse",
#                     verbose = TRUE,
#                     print_every_n = 50,
#                     nfold = 4,
#                     nthread = 2,
#                     objective="reg:linear")
# 
# #Train the model
# #Choose the parameters for the model
# param <- list(colsample_bytree = .7,
#              subsample = .7,
#              booster = "gbtree",
#              max_depth = 10,
#              eta = 0.02,
#              eval_metric = "rmse",
#              objective="reg:linear")
# 
# 
# #Train the model using those parameters
# bstSparse <-
#   xgb.train(params = param,
#             data = trainD,
#             nrounds = 600,
#             watchlist = list(train = trainD),
#             verbose = TRUE,
#             print_every_n = 50,
#             nthread = 2)
# 
# testD <- xgb.DMatrix(data = trainHCtestNum)
# 
# prediction <- predict(bstSparse, testD) #Make the prediction based on the half of the training data set aside
# 
# #Put testing prediction and test dataset all together
# 
# prediction <- as.data.frame(as.matrix(prediction))
# colnames(prediction) <- "xgboost"
# trainHCtest$xgboost <- prediction$xgboost
# 
# 
# #Test with RMSE
# rmse(trainHCtest$LogSalePrice, trainHCtest$xgboost)
# 
# # Feature importance
# importance_matrix <- xgb.importance(dimnames(trainD)[[2]], model = bstSparse)
# xgb.plot.importance(importance_matrix[1:10])
```


Use the glmnet library to train a ridge regression model. Is it more or less accurate than XGBoost? 

```{r RidgeReg}
# trainHCtrainNumMatrix <- as.matrix(trainHCtrain[ , sapply(trainHCtrain, is.numeric)])
# trainHCtestNumMatrix  <-  as.matrix(trainHCtest[ , sapply(trainHCtest, is.numeric)])
# # cross validation for glmnet
# glm.cv.ridge <- cv.glmnet(trainHCtrainNum[,c(1:38,40)], trainHCtrainNum[,"LogSalePrice"], alpha = 0)
# # which lambda?
# penalty.ridge <- glm.cv.ridge$lambda.min
# glm.ridge <- glmnet(x = trainHCtrainNum[,c(1:38,40)], y = trainHCtrainNum[,"LogSalePrice"], alpha = 0, lambda = penalty.ridge )
# y_pred.ridge <- as.numeric(predict(glm.ridge, trainHCtestNum[,c(1:38,40)] ))
# rmse(trainHCtest$LogSalePrice, y_pred.ridge)
```

